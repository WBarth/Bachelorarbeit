\section{Überarbeitung des MSC}
Zum Beginn dieser Arbeit muss der Dongle jedes Mal, wenn die Konfigurationsfiles geändert wurden, ab- und wieder eingesteckt werden, damit die Anwendung neugestartet und die Files erneut eingelesen werden. Beim Fußschalter ergibt sich nun das Problem, dass das Gerät einen Akku besitzt, weswegen ein harter Reset durch den Anwender nicht möglich ist.

\subsection{Evaluierung der Möglichkeiten zur Detektion}
Der erste Versuch der Unternommen wurde um dem Anwendungsfall gerecht zu werden, ist über die File Information des Fat Filesystems den Änderungszeitpunkt auslesen und falls er sich im Vergleich zum Zeitpunkt, der beim erstmaligen Einlesen festgestellt wurde, geändert hat, ein Systemreset durchzuführen. Dabei hat sich jedoch gezeigt, dass eine Änderung am File keine Veränderung am Änderungszeitpunkt hervorruft. Erst nach einem manuellen Reset zeigt sich das korrekte Änderungsdatum in der File Information. \\
Ein weiterer Versuch war es, direkt zu überprüfen ob neue Daten über das Blockdevice geschrieben wurden. Dies führte jedoch dazu, dass der System Reset durchgeführt wurde, bevor alle Daten vollständig geschrieben wurden. Zudem hat diese Implementierung weitere Probleme, wie zum Beispiel, dass ein Formatieren des Datenträgers, wie er bei der ersten Inbetriebnahme durchgeführt werden muss, nicht mehr möglich war. \\
Ein periodisches Neueinlesen der Daten war hingegen nicht möglich, weil bei dem Read Befehl die Anwendung in einer Warteschleife festhing. Es zeigte sich, dass sowohl MSC als auch das Fat Filesystem auf die gleiche Instanz des Blockdevice versucht haben zuzugreifen, was grundsätzlich nicht möglich ist. Ein Anlegen einer weiteren Instanz des Blockdevice für das Filesystem behob dieses. \\
In einer zwischenzeitlichen Lösung des Problems werden die Konfigurationsfiles periodisch neugelesen und über die Daten ein Hashwert gebildet. Anhand dieses Wertes wird dann eine Änderung festgestellt. Hat sich das globale Konfigurationsfile geändert wird ein Systemreset durchgeführt, während bei einer Änderung des Files der zu verbindenden Geräte, die Verbindung zu allen Geräten getrennt wird und das File anschließend neueingelesen, wodurch der Verbindungsaufbauprozess neu gestartet wird. Jedoch zeigte sich, dass es Änderungen, die am Ende der Datei stattgefunden haben nicht detektiert werden.

\subsection{Einlesen der Länge der Datei}
Es hat sich gezeigt, dass die Länge der Datei nicht erneut eingelesen wird, wenn die Datei aus Windows heraus geändert wird und nicht aus dem Filesystem auf dem Chip. Daher können Änderungen an den Dateien die ausschließlich hinten an dem bestehenden Text angefügt werden, nicht detektiert werden können, da die Datei mit der alten Länge eingelesen wird. Jedoch konnte festgestellt werden, dass die Information korrekt im Speicher vorhanden ist, aber nicht ins interne Filesystem übernommen wird. Es besteht also die Möglichkeit die Informationen selbstständig einzulesen. Dazu muss als Erstes das ``Directory Entry'' gefunden werden. Es steht nach den ``File Allocation Tables'' (FAT). Daher müssen folgende Informationen aus der Boot Section ausgelesen werden und folgende Berechnung durchgeführt werden: 

\(Startadresse FS + Sektorengroeße*Anzahl reservierter Sektoren + Sektorengroeße*Anzahl FAT*Anzahl Sektoren pro FAT = Startadresse FS + Sektorengröße * (Anzahl reservierter Sektoren + Anzahl FAT*Anzahl Sektoren pro FAT)\)

Diese Informationen stehen jedoch immer an der gleichen Stelle im Bootsektor und ändern sich während des Betriebs des Fußschalters nicht. \\
Im Directory Entry wird jeweils für die Informationen einer Datei 32 Bytes verwendet und innerhalb dieser 32 Bytes befinden sich die Informationen immer an der gleichen Stelle, weshalb mit festen Offsets gearbeitet werden kann. Jedoch wird ein Eintrag nicht sofort gelöscht, wenn die Datei gelöscht wird, sondern die Filenamen durch Ersetzten des ersten Buchstaben durch 0x5a invalidiert. Daher muss der valide Eintrag immer wieder neu gesucht werden. Es zeigt sich zudem, dass das Directory Entry größer als ein Sektor werden, auch wenn er nur zwei Dateinamen beeinhaltet. Das liegt daran, dass bei Löschen und Neuanlegen der Dateien, zum Beispiel beim Kopieren der Dateien aus einem Verzeichnis auf dem Computer, die alten Einträge nicht gelöscht sondern entvalidiert werden. Es wird daher nacheinander die Sektoren, die für das Directory Entry allkiert sind einzulesen und auf die korrekten Dateinamen hin zu untersuchen.

\subsection{Finale Lösung}
Das Hauptproblem des MSC ist, dass es immer wieder dazu kommt, dass Schreibbefehle fehlschlagen und die Daten unvollständig in den Speicher übertragen werden. Nachforschungen ergeben, dass die Zugriffe auf den Flash vom Softdevice abgearbeitet werden müssen. Bestehen also mehrere aktive Verbindungen steigt die Wahrscheinlichkeit von Fehlerhaften Schreibzugriffen stark an. Getätigte Änderungen an den Konfigurationsfiles werden dann nicht übernommen und sind selbst nach langen Wartenzeiten, nach dem Reset verloren gegangen. Deshalb werden, falls Schreibzugriffe gequeuet sind, alle Aktivitäten des Softdevice gestoppt, um die Gefahr von Fehlern beim Schreiben und die benötigte Zeit zu minimieren. Das umfasst das Trennen aller Verbindungen, sowie das Stoppen von Advertising und scanning. Da durch einen gestarteten Timer der Fußschalter ohnehin neugestartet werden soll, damit die Konfigurationsfile neueingelesen werden können, ist die Beeinträchtigung der User Experience vernachlässigbar. 
