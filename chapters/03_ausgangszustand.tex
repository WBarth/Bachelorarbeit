\section{Ausgangszustand}
\label{Ausgangszustand}
Zum Beginn dieser Arbeit wurde bereits in meiner vorangegangenen Tätigkeit bei der Hoffmann Group auf Basis des NRF52840-Dongle prototypisch eine Anwendung implementiert, die auf das Bluetooth Modul der Hoffmann Group aufbaut und zusammen mit diesem die Basis für die Anwendung des Fußschalters darstellt. Das Bluetooth Modul stellt dabei die Anwendungsschicht des \ac{BLE}-Stack dar und abstrahiert somit die \ac{BLE} spezifischen Aufrufe zum Softdevice. Als Softdevice wird das S140 von Nordic Semiconductor in der Version 7.2.0 verwendet. Das S140 ist ein vorkompilierter BLE Protokoll Stack von Nordic Semiconductor. (\cite{NRF_Softdevice}) Der Proof-of-Concept Prototyp soll vor allem zeigen, dass es möglich ist eine Anwendung auf demselben Chip wie das Bluetooth Modul und das Softdevice laufen zu lassen, die in der Lage ist einerseits ein Massenspeichermedium und einen virtuellen COM-Port zu öffnen und andererseits über \ac{BLE} mehrere \ac{HCT}-Werkzeuge verbindet. Als solche war der Prototyp ein voller Erfolg und schaffte die Bereitschaft des Projektmanagements die Ressourcen für die Implementierung des Fußschalters zu bewilligen.\\
In diesem Kapitel werden die Funktionalität und der Aufbau der Dongle-App sowie die notwendigen Änderungen und Verbesserungen, die durchgeführt werden sollen, vorgestellt. Damit soll auch die Implementierung für den Fußschalter von den bestehenden abgegrenzt werden.

\subsection{Dongle-App}
Die Anwendung nutzt das Bluetooth Modul der Hoffmann Group, welches in allen \ac{HCT}-Werkzeugen eingesetzt, wo es eine Vermittlerfunktion zwischen dem eigentlichen Gerätechip und dem Softdevice übernimmt. Dabei kann es sowohl in der peripheral und central Rolle agieren. Es führt den Verbindungsprozess zu Computern und \ac{HCT}-Geräten durch. \\
Auf diesem Basisprojekt aufbauend befindet sich die \ac{USB}-Dongle App. Dieser Aufbau ist in Abbildung \ref{fig:AufbauAusgangszustand} zu sehen. Im Gegensatz zu den \ac{HCT}-Werkzeugen sitzt die gesamte Anwendung ebenfalls auf dem Chip des Softdevice und muss sich die Chipressourcen mit ihm teilen. Die Funktionalität, die in dem File usb\_dongle\_app.c gekapselt ist, ist dafür zuständig das Konfigurationsfile einzulesen und die zugehörigen Daten während der Laufzeit zu halten. Dabei handelt sich es um die zu verbindenden \ac{HCT}-Gerät, welche in einer gleichnamigen Struktur mit Name, Seriennummer und einer Kanalzuweisung gespeichert werden. Die Kanalzuweisung wird für das MUX50 bzw. DMX16 Protokoll benötigt. Die Protokolle MUX50 bzw. DMX16 sind dabei proprietäre, \ac{ASCII}-basierte Protokolle und stellt jeweils nur eine leichte Variation des Anderen dar (\cite[s. 33]{HCT_Windows_App_Manual}). Sie werden benötigt um die Daten an eine \ac{CAQ}-Software weiterzugeben, welche die Messdaten speichern und auf ihre Richtigkeit überprüfen kann. Werden die Geräte dann verbunden, muss weiterhin der Verbindungszustand sowie das Connection-Handle gespeichert werden. Des Weiteren sammelt die Anwendung die Messdaten auf, die vom Central Device von den \ac{HCT}-Geräten im Interrupt-Kontext empfangen werden und reiht die Daten, die von Interesse sind, in eine \ac{FIFO}-Nachrichtenqueue ein. Diese werden später aus dem Kontext der Main-Loop heraus, in das MUX50 bzw. DMX16 Protokoll umgewandelt und über den virtuellen COM-Port verschickt. Ebenfalls in der Funktionalität des usb\_dongle\_app.c Files und aus dem Kontext des Main-Loop heraus, werden die Befehle des MUX50 Protokolls, welche über dem virtuellen COM-Port empfangen werden, verarbeitet.\\
In dem File usbd\_msc\_cdc\_composite.c werden \ac{USB} spezifischen Aufrufe gekapselt. Hier wird das \ac{MSC} und der virtuelle COM-Port (\ac{CDC}) initialisiert und konfiguriert. Der Code wurde nur mit kleinen Änderungen aus den Beispielen des nRF SDKs übernommen (\cite{NRF_USB_examples}), weswegen nicht weiter auf die Implementierung eingegangen wird.\\
Da es keine Unterstützung seitens der NRF Bibliothek für den internen Flash als Speichermedium für das \ac{MSC} gibt (\cite{NRF_MSC_Forum}), muss der Treiber block\_device\_ram.c (\cite{NRF_Block_device_RAM}) angepasst werden. Das Treiber File wird als block\_dev\_fStorage.c in das Projekt gezogen und ruft die Funktionen des Files fStorage.c auf, welches die Schreibbefehle im Interrupt-Kontext ebenfalls in eine \ac{FIFO} Nachrichtenqueue einreiht. Das ist nötig, da für die korrekte Ausführung auf Interrupts des Flash Memory gewartet werden muss, welche nur im Kontext der Main-Loop korrekt empfangen werden. Zudem wird dort Flash Memory spezifische Logik abstrahiert. So muss eine Flash Page erst ``erased'' werden, bevor sie geschrieben werden kann und die Block Logik des \ac{MSC} wird auf die Flash Page Logik des Speichers übertragen.

\begin{figure}[H] 
	\centering
	\includegraphics[width=\textwidth]{figures/Design_Model.png}
	\caption{Aufbau des Projekts im Ausgangszustand}
	\label{fig:AufbauAusgangszustand}
\end{figure}


\subsection{Erweiterungen für Fußschalter}
Für den Fußschalter wurden folgende funktionale Anforderungen erarbeitet:
\begin{itemize}
	\item Der Fußschalter soll sich automatisch mit den konfigurierten \ac{HCT}-Werkzeugen verbinden 
	\item Wenn der Schalter betätigt wird, soll der Fußschalter eine Messwerterfassung bei den Geräten triggern
	\item Die erfassten Messwerte sollen je nach Verbindungs-Konfiguration einem Rechner kabelgebunden über HID, kabelgebunden über eine USB-COM-Schnittstelle im MUX50 oder im DMX16-Format oder via BLE-HID übermittelt werden.  
	\item Dabei sollen die Messwerte und deren Einheit den Geräten eindeutig zugeordnet werden können, einerseits durch die Anordnung im HID-String oder einer Angabe der Kanalnummer im HID-String, andererseits durch die Kanalnummer im MUX50/DMX16 Protokoll 
	\item Eine dedizierte Gruppen-Messfunktion soll ermöglichen, dass die für die Gruppenmessung konfigurierten Geräte gleichzeitig getriggert werden und somit die Messergebnisse einem bestimmten Messzeitpunkt zugeordnet werden können
	\item Eine sequenzielle Gruppenfunktion soll ermöglich, dass die für die Gruppenmessung konfigurierten Geräte mit dem Fußschalter einzeln in der konfigurierten Reihenfolge getriggert werden können
	\item Dem Benutzer soll eine einfache Parametrierungs-Möglichkeit, sowohl für die notwendigen zu verbindenden HCT-Geräte, als auch zur Konfiguration der Anschluss- und Messmodi zur Verfügung gestellt werden. Dies soll in Form von einfach zu editierenden Dateien erfolgen, die durch den Fußschalter über ein Laufwerk als Massenspeicher angeboten werden
	\item Der Fußschalter soll dem Benutzer seinen Zustand anzeigen können
	\item Die Zustandsanzeige soll umfassen
	\begin{itemize}
		\item die Initialisierung
		\item das Scannen der Geräte bzw. das Advertisen bei BLE-HID-Verbindung
		\item den Verbindungszustand, wenn alle konfigurierten Geräte verbunden sind 
		\item das Herunterfahren
		\item einen aufgetretenen Fehler
	\end{itemize}
\end{itemize}

Die nichtfunktionalen Anforderungen sind:
\begin{itemize}
	\item Es sollten bis zu 5 HCT-Verbindungen mit einem Verbindungsintervall von 60 ms sicher gehalten werden
	\item Das Verbindungsintervall im HID-Modus zu einem PC bzw. Master-Device soll 30 ms betragen
\end{itemize}

Für den Fußschalter muss die bestehende Software wie folgt erweitert werden. Die Peripherie des Fußschalters muss eingebunden werden. Diese umfasst den Schalter, der durch den Anwender betätigt wird, eine LED-Leuchte und den Akku des Fußschalters. In Hinblick auf den Akku muss ein Energiemanagement geschaffen werden, um dessen Kapazität zu schonen. Während die Dongle-App die Daten ausschließlich über den virtuellen COM-Port zur Verfügung stellt, soll im Fußschalter die Art der Ausgabe konfigurierbar sein. Des Weiteren müssen die Schreibbefehle des \ac{MSC} optimiert werden, da sie nur sehr langsam und fehlerbehaftet abgearbeitet werden. Die Änderungen an der Konfiguration der Anwendung wird außerdem erst übernommen, wenn der Dongle abgezogen und wieder angesteckt wird, also die Anwendung neugestartet wird. Beim Fußschalter sollen Änderungen an den Konfigurationsfiles detektiert werden und die Anwendung programmatisch neugestartet werden, auch weil durch den Akku die Anwendung durch den Nutzer nicht direkt neugestartet werden kann.  müssen die Messuhren bzw. Messschieber eingebunden werden. Zusätzlich soll die Anwendung weiterhin auch als Dongle erhältlich gemacht werden und die Implementierung muss in Hinblick auf diese Hardwarunterschiede durchgeführt werden. 
Für den Fußschalter muss die bestehende Software wie folgt erweitert werden. Die Peripherie des Fußschalter muss eingebunden werden. Diese umfasst den Schalter der durch den Anwender betätigt werden kann, eine LED-Leuchte und den Akku des Fußschalters. In Hinblick auf den Akku muss eine Energiemanagement geschaffen werden, um dessen Kapazität zu schonen. Während die Dongle-App die Daten ausschließlich über den virtuellen COM-Port zur Verfügung stellt, soll im Fußschalter die Art der Ausgabe konfigurierbar sein. Des Weiteren müssen die Schreibbefehle des \ac{MSC} optimiert werden, da sie nur sehr langsam und fehlerbehaftet abgearbeitet werden. Die Änderungen an der Konfiguration der Anwendung wird außerdem erst übernommen, wenn der Dongle abgezogen und wieder angesteckt wird, also die Anwendung neugestartet wird. Beim Fußschalter sollen Änderungen an den Konfigurationsfiles detektiert werden und die Anwendung programmatisch neugestartet werden, auch weil durch den Akku die Anwendung durch den Nutzer nicht direkt neugestartet werden kann. Außerdem müssen die Messuhren bzw. Messschieber eingebunden werden. Zusätzlich soll die Anwendung weiterhin auch als Dongle erhältlich sein und die Implementierung muss in Hinblick auf diese Hardwarunterschiede durchgeführt werden. 